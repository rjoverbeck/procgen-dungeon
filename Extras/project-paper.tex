\documentclass[a4paper, 12pt, one column, aas_macros]{article}

%% Language and font encodings. This says how to do hyphenation on end of lines.
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{aas_macros}

%% Sets page size and margins. You can edit this to your liking
\usepackage[top=1.3cm, bottom=2.0cm, outer=2.5cm, inner=2.5cm, heightrounded,
marginparwidth=1.5cm, marginparsep=0.4cm, margin=2.5cm]{geometry}

%% Useful packages
\usepackage{graphicx} %allows you to use jpg or png images. PDF is still recommended
\usepackage[colorlinks=False]{hyperref} % add links inside PDF files
\usepackage{amsmath}  % Math fonts
\usepackage{amsfonts} %
\usepackage{amssymb}  %

%% Citation package
\usepackage[authoryear]{natbib}
\bibliographystyle{abbrvnat}
\setcitestyle{authoryear,open={(},close={)}}


\title{Project Paper}
\author{Ryan Overbeck}

\begin{document}
\maketitle

\begin{abstract}
Add abstract here
\end{abstract}

\section{Introduction}

Add introduction here

\section{Binary Space Partitioning Approach}
\begin{quote}
  \emph{"A binary space partition takes a given space and splits it in half, and then takes the two areas that were created and splits those in half, and repeats until some threshold is reached."}
  \cite[p.~293]{ShortAdams2017}
\end{quote}

This quote sums up our first approach to procedurally generate rooms for our 2D dungeon. In this implementation, we define a rectangular region---the entire dungeon area---and iteratively subdivide it into smaller rectangles (potential ``rooms'') until no further meaningful subdivision is possible Lastly, some offset is applied to create space between these rooms. The following outlines how this simplified Binary Space Partitioning (BSP) approach is handled in our Unity project.

\subsection{Setting up the Initial Partition}
The process begins by defining a single large bounding area using a \texttt{BoundsInt} structure. As noted in the Unity documentation, the \texttt{BoundsInt} structure ``represents an axis aligned bounding box with all values as integers'' \citep{unity_docs}. This is useful for several reasons, among them since \texttt{BoundsInt} uses integer coordinates, it aligns naturally with tile-based systems (where tiles or grid cells are also defined by integral x, y positions).

Next, this bounding area is enqueued in a \texttt{Queue<BoundsInt>} which manages partitions that still need to be processed. A queue-based approach was selected to keep the partitioning logic simple and easy to follow. A stack-based approach would have worked equally as well---only changing the order of processing.

\subsection{Iterative Subdivision}
While there are partitions in the queue:
\begin{itemize}
  \item Dequeue the next partition.
  \item Check if the current partition meets or exceeds the \emph{minimum width} (\texttt{minWidth}) and \emph{minimum height} (\texttt{minHeight}) constraints.
  \item If it can be subdivided, choose randomly whether to \emph{prefer a horizontal} or \emph{vertical} split (a 50/50 chance). Attempt to partition the space along that orientation if there is sufficient size to do so at least twice (e.g., if the height is at least \texttt{2 * minHeight} for a horizontal split).
  \item If the chosen orientation is not feasible, try the alternative orientation.
  \item If neither orientation is possible (the partition is too small), mark that partition as finalized (a ``room'') and add it to the \texttt{partitions} list.
\end{itemize}

\subsection{Managing Subdivisions}
The actual subdivision is performed in two helper methods, \texttt{PartitionHorizontally} and \texttt{PartitionVertically}. These methods randomly determine a \emph{split point} within the valid range and create two new \texttt{BoundsInt} objects representing the subdivided spaces. Each new partition is enqueued for further subdivision if possible.

\begin{itemize}
  \item \emph{Horizontal Partition:} Splits along the y-axis, producing a top and bottom rectangle.
  \item \emph{Vertical Partition:} Splits along the x-axis, producing a left and right rectangle.
\end{itemize}

By alternating or randomly selecting horizontal versus vertical splits, the algorithm produces layouts of different shapes, preventing overly predictable results.


\bibliography{references}
\end{document}